## 阅读《Chimp: Efficient Lossless Floating Point Compression for Time Series Databases》

本文是对论文 [《Chimp: Efficient Lossless Floating Point Compression for Time Series Databases》](https://vldb.org/pvldb/vol15/p3058-liakos.pdf) 的简单解读，详细内容、图表等可以参考原文。

论文中还提供了算法的实现代码 [chimp](https://github.com/panagiotisl/chimp)。

### 背景

大规模时序数据处理（存储、分析）中的一大课题就是数据的编码，这涉及到数据的存取效率。在大多数场景（气候、经济、工业生产等）中，都可以使用（双精度）浮点数作为基础数据类型。

因此，本篇论文提出了一种新的无损浮点数（流式）压缩编码方式，并宣称它在面对通用压缩算法和早先的同样针对时序数据场景的流式算法时，都有更好的时空综合表现。文中尤其以 [《Gorilla: A Fast, Scalable, In-Memory Time Series Database》](https://www.vldb.org/pvldb/vol8/p1816-teller.pdf)（以下简称 Gorilla）这一在工业界被广泛使用的算法作为对比的对象。

文中提到，目前大多数针对时序浮点数的压缩（包括 Gorilla）都使用了“基于相邻的两个浮点数值按位异或结果，再消除结果中的零位”的做法。这种做法是比较有效的。

作者在分析了一些真实世界数据集之后认为，`Gorilla` 这类算法对于相邻值异或结果的特征假设存在一定偏差，这导致了这类算法在空间效率方面表现不如人意。

作者针对这一情况进行了一些优化，形成了本篇论文。

### 预备知识

正文中先介绍了浮点数时间序列的定义、IEEE 754 双精度浮点数的格式定义、Gorilla 压缩算法的浮点数编码方式，此处略过。

### 真实时间序列的性质

这里作者选取了 14 种真实世界中常见的时序数据集，包括气候、环境、金融等场景，从以下几方面进行了分析并得出一定结论：

#### 尾部零位
- 除了两组数据集“PM-10颗粒”和“气压”外，相邻两个值相等的情况极为少见
- 几乎没有出现 64个 尾部零位的情况
- 极大概率，尾部仅有少于6个零位
- 仅有三个数据集出现了“拥有 6-63位尾部零位”占比比较明显这样的情形（从文中的图标来看，这个明显的比例大约是 `>5%`），而这三个数据集又有一些特征，例如：
  - 小数部分精度较低
  - 使用一些特定的小数部分数值


#### 头部零位
在双精度浮点数的表示中，前 12个 bit 位用于表示符号和指数，因此，在数值没有大幅变化的情况下，大多数数值这12位都是相同的。而这一点又导致，大多数情况下，至少这12位的异或结果都会维持全零。

针对具体的数据集：
- 有三个数据集会出现明显的、小于12个头部零位的情况，这意味着他们会出现比较明显的指数变化
- 只有“气压”这个数据集大规模出现大量头部零位的情况，但通常也不会超过30个零位

  这是由数据集中的数值通常存在较大的整数部分导致的。

#### Gorilla 算法的回归
这部分是结合 Gorilla 算法的具体实现和上述性质来分析，不具体解读

### 算法实现

针对满足上一节所提到的性质的典型场景，作者设计了优化的压缩算法，即 `Chimp`。

#### Chimp 算法
1. 标记位（flag）：

   算法使用 2bit 标记位，将相邻值的异或结果分为4种情况：
   1. `00` 结果为 0
   2. `01` 尾部零位大于 $log_{2}64$，之后使用 3bit 记录头部位数，6bit 记录中段位数，最后记录中段的有效位数据
   3. `10` 尾部零位小于等于 $log_{2}64$，且两个值头部相等，之后记录非头部的数据
   4. `11` 尾部零位小于等于 $log_{2}64$，且两个值头部不等，之后使用 3bit 记录头部位数，最后记录非头部数据

2. 头部位数的计算方式：

   使用4bit来表示 `[0, 30]` 之间的所有偶数值，如果计数是奇数，则将最后一个0位归入有效位数

   这种做法下的数据紧凑程度不会低于 Gorilla 使用 5bit 表示 `[0, 31]` 之间所有值的做法，证明过程略过

   而根据标记位的解读，实际实现中只使用了 3bit，这是将8个计数值映射为 `[0, 8, 12, 16, 18, 20, 22, 24]` 的实际值之后的结果

3. 中段（有效）位数的计算方式：

   使用 6bit 来全量表示有效位数长度

4. 使用前值的头部零位数量：

   当尾部零位小于等于 6 位时，尝试使用前值的头部零位数量来辅助降低需要使用的位数

5. 算法步骤：略过

#### 变体 $CHIMP_{128}$
相比原生的 `Chimp` 算法，这个变体的变化体现在几个方面：
1. 使用 ring buffer 记录128个前值用作对比
2. 每次比较时，与128个前值依次对比，并选取尾部零位数量最大的结果，产生此结果的前值称为最佳值
3. 比较过程中，分支的阈值从 $log_{2}64$ 调整为 $log_{2}128 + log_{2}64$
4. 尾部零位数量大于阈值的情况下，数据记录格式中额外增加 7bit 用于记录最佳值的下标结果

#### Chimp 及变体算法的简单总结：
`Chimp` 算法的核心思路是：针对作者认为最频繁的场景——尾部零位数量小于等于 6 且头部零位数量有较大概率不发生改变——减少 **必须** 记录的数据位数。

而减少的方法，是复用 `头部零位数量` 。

而 $CHIMP_{N}$ 变体的思路，则是扩大标准场景的覆盖比例：通过在一些不那么频繁的分支中记录少量额外的数据来扩大典型分支的阈值。

前值数量 128 则是作者在综合了速度和额外数据量之后的认定结果。

显然，这种变体做法带来了不少额外的计算量，因此作者提供了一种降低计算量的优化做法：

除了 记录前值的 ring buffer 外，额外增加一个容量为 $2^{14}$ 的数组用于记录 **最近一个低14位等于数组下标值的前值序号**，这样，
如果当前值的低14位对应的前值在前128个值范围内时，可以直接提取其序号，而不必执行完所有异或。


### 实际效果
作者使用符合论文中所提及的典型场景的一组数据集，分别使用
- 通用压缩算法 `Xz`、`Brotli`、`LZ4`、`Zstd`、`Snappy` 等
- 流式压缩算法 `FPC`、`Gorilla` 等

进行对比测试。

作者为广泛使用的时序数据库 `InfluxDB` 添加了对 `Chimp` 的支持，来和它原生使用的基于 `Gorilla` 的实现进行对比。

#### 压缩率
1. 根据数据集的不同，通用算法相比流式算法，普遍能节约 50% ~ 80% 空间
2. `Chimp` 算法相比其他流式算法，大多有微弱优势
3. $CHIMP_{128}$ 算法相比其他流式算法，能节约 50% ~ 70% 的空间，表现接近通用算法的中间水平

#### 压缩和解压时间
对于时序数据，按照 1000 数值/块 进行压缩和解压耗时统计

1. 关于压缩耗时：
   - `Xz`、`Brotli`、`LZ4` 三者耗时均在 1000us 以上
   - `Zstd` 耗时 ~160us, `Snappy` 耗时 ~90us
   - 流式算法普遍在 30us ~ 60us，`Chimp` 和 $CHIMP_{128}$ 相比其他流式算法都有微弱优势

2. 关于解压耗时:
   - 除了 `Xz` 耗时 ~300us 之外，其他通用算法都在 25us ~ 60us 之间
   - 流式算法在 28us ~ 40us 之间，相比表现较好的通用算法来说，没有明显优势
   - `Chimp` 和 $CHIMP_{128}$ 相比其他流式算法依然有微弱优势

#### 时间和空间的平衡
结论当然是 `Chimp` 和 $CHIMP_{128}$ 提供了不错的综合表现。

#### 单精度数据和有损压缩
这种场景不是很常见，略过。


### 阅读总结
1. 相比通用压缩算法来说，流式算法在时序数据，尤其是时序数据的实时采集阶段有着非常良好的适用性，这是一切的基础。
2. 作为被业界的时序数据库实现广泛使用的流式压缩算法，`Gorilla` 提供了非常有效的思路，并且兼顾了整数类型和浮点数类型。
3. 本论文针对的是 `Gorilla` 在浮点数压缩这个单一场景的表现，作者认为 `Gorilla` 的具体实现不能很好地优化作者提出的“典型场景”。

   针对这个观点，我们需要考虑到 Facebook 提出 `Gorilla` 算法主要是用于它的巨量设备、服务监控。
   这种场景下是否 `Gorilla` 已经提供了足够优秀的表现，我们无法验证。

   当然，针对作者认为的典型场景，`Chimp` 及其变种确实提供了不错的表现。这种优势是否能扩大到更广泛的场景中，有待验证。

4. 在具体实现中，`Chimp` 及其变种应该能收益与一些其他技术，如 `SIMD` 等。
5. 在与通用算法的比较方面，我们应当注意：
   1. 压缩解压的耗时，有一些先决条件，如数据分块方式等。随着这些条件的变化，耗时将出现何种变化趋势？有待进一步的验证。
   2. 在压缩率方面，通用压缩算法有着明显的优势。对于时序数据库来说，是否存在流式算法和通用算法并存的空间？
      比如使用通用压缩算法来处理归档数据等。
   3. 综合时间和空间，`Zstd` 和 `Snappy` 真的很强。
